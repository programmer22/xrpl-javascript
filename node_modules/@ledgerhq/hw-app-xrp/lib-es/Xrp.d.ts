import type Transport from "@ledgerhq/hw-transport";
/**
 * XRP API
 *
 * @example
 * import Transport from "@ledgerhq/hw-transport-node-hid";
 * // import Transport from "@ledgerhq/hw-transport-u2f"; // for browser
 * import Xrp from "@ledgerhq/hw-app-xrp";
 * import { encode } from 'ripple-binary-codec';
 *
 * function establishConnection() {
 *     return Transport.create()
 *         .then(transport => new Xrp(transport));
 * }
 *
 * function fetchAddress(xrp) {
 *     return xrp.getAddress("44'/144'/0'/0/0");
 * }
 *
 * function signTransaction(xrp, deviceData, seqNo) {
 *     let transactionJSON = {
 *         TransactionType: "Payment",
 *         Account: deviceData.address,
 *         Destination: "rTooLkitCksh5mQa67eaa2JaWHDBnHkpy",
 *         Amount: "1000000",
 *         Fee: "15",
 *         Flags: 2147483648,
 *         Sequence: seqNo,
 *         SigningPubKey: deviceData.publicKey.toUpperCase()
 *     };
 *
 *     const transactionBlob = encode(transactionJSON);
 *
 *     console.log('Sending transaction to device for approval...');
 *     return xrp.signTransaction("44'/144'/0'/0/0", transactionBlob);
 * }
 *
 * function prepareAndSign(xrp, seqNo) {
 *     return fetchAddress(xrp)
 *         .then(deviceData => signTransaction(xrp, deviceData, seqNo));
 * }
 *
 * establishConnection()
 *     .then(xrp => prepareAndSign(xrp, 123))
 *     .then(signature => console.log(`Signature: ${signature}`))
 *     .catch(e => console.log(`An error occurred (${e.message})`));
 */
export default class Xrp {
    transport: Transport;
    constructor(transport: Transport, scrambleKey?: string);
    /**
     * get XRP address for a given BIP 32 path.
     *
     * @param path a path in BIP 32 format
     * @param display optionally enable or not the display
     * @param chainCode optionally enable or not the chainCode request
     * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)
     * @return an object with a publicKey, address and (optionally) chainCode
     * @example
     * const result = await xrp.getAddress("44'/144'/0'/0/0");
     * const { publicKey, address } = result;
     */
    getAddress(path: string, display?: boolean, chainCode?: boolean, ed25519?: boolean): Promise<{
        publicKey: string;
        address: string;
        chainCode?: string;
    }>;
    /**
     * sign a XRP transaction with a given BIP 32 path
     *
     * The rawTxHex parameter is the serialized transaction blob represented as
     * hex.
     *
     * @param path a path in BIP 32 format
     * @param rawTxHex a raw hex string representing a serialized transaction blob.
     *        This parameter can be encoded using [ripple-binary-codec](https://www.npmjs.com/package/ripple-binary-codec).
     *        See https://xrpl.org/serialization.html for more documentation on the serialization format.
     * @param ed25519 optionally enable or not the ed25519 curve (secp256k1 is default)
     * @return a signature as hex string
     * @example
     * const signature = await xrp.signTransaction("44'/144'/0'/0/0", "12000022800000002400000002614000000001315D3468400000000000000C73210324E5F600B52BB3D9246D49C4AB1722BA7F32B7A3E4F9F2B8A1A28B9118CC36C48114F31B152151B6F42C1D61FE4139D34B424C8647D183142ECFC1831F6E979C6DA907E88B1CAD602DB59E2F");
     */
    signTransaction(path: string, rawTxHex: string, ed25519?: boolean): Promise<string>;
    /**
     * get the version of the XRP app installed on the hardware device
     *
     * @return an object with a version
     * @example
     * const result = await xrp.getAppConfiguration();
     *
     * {
     *   "version": "1.0.3"
     * }
     */
    getAppConfiguration(): Promise<{
        version: string;
    }>;
}
//# sourceMappingURL=Xrp.d.ts.map